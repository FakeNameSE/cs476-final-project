mod CLIENT-SERVER is
    protecting NAT .
    extending CONFIGURATION .

    sorts ClientId ServerId ClientConf ServerConf ClientObj ServerObj .
    subsorts ClientId ServerId < Oid .
    subsorts ClientConf ServerConf < Configuration .
    subsort ClientObj < ClientConf .
    subsort ServerObj < ServerConf .
    subsort Msg < ClientConf .
    subsort Msg < ServerConf .

    ops Client Server Attacker : -> Cid [ctor] .
    --- ops C_ S_ A_ : Nat -> Oid [ctor] .
    op C_ : Nat -> ClientId [ctor] .
    op S_ : Nat -> ServerId [ctor] .
    op (to_,_from_) : Oid AttributeSet Oid -> Msg [ctor msg] .

    --- Attributes for client.
    op server:_ : ServerId -> Attribute [ctor gather (&)] .
    ops seq:_ ack:_ maxSeq:_ : Nat -> Attribute [ctor gather (&)] .
    op msgSeq:_ : Nat -> Attribute [ctor gather (&)] .
    op disconnect : -> Attribute [ctor] .

    op C<_:_|_> : ClientId Cid AttributeSet -> ClientObj [ctor object] .
    op S<_:_|_> : ServerId Cid AttributeSet -> ServerObj [ctor object] .
    op cnone : -> ClientConf [ctor] .
    op snone : -> ServerConf [ctor] .
    op _c;_ : ClientConf ClientConf -> ClientConf [ctor config assoc comm id: cnone] .
    op _s;_ : ServerConf ServerConf -> ServerConf [ctor config assoc comm id: snone] .

    var CLIENTID1 : ClientId .
    var SERVERID1 : ServerId .
    vars ATTRS1 ATTRS2 : AttributeSet .
    vars N1 N2 N3 : Nat .

    crl [client-send] : C< CLIENTID1 : Client | server: SERVERID1, seq: N1, ack: N1, maxSeq: N2 > => 
        (to SERVERID1, (msgSeq: N1, (if N1 == N2 then disconnect else none fi)) from CLIENTID1) c; 
        C< CLIENTID1 : Client | server: SERVERID1, seq: N1 + 1, ack: N1, maxSeq: N2 > if N1 <= N2 .

    *** Only takes the message if it is the next one, drops it otherwise.
    rl [client-rcv] : (to CLIENTID1, (msgSeq: N1, ATTRS2) from SERVERID1) c; C< CLIENTID1 : Client | server: SERVERID1, seq: N2, ack: N3, ATTRS1 > =>
        if N1 == N3 then
            C< CLIENTID1 : Client | server: SERVERID1, seq: N2, ack: N3 + 1, ATTRS1 > 
        else 
            C< CLIENTID1 : Client | server: SERVERID1, seq: N2, ack: N3, ATTRS1 > 
        fi .

    rl [server-reply] : (to SERVERID1, ATTRS1 from CLIENTID1) s; S< SERVERID1 : Server | none > => (to CLIENTID1, ATTRS1 from SERVERID1) s; S< SERVERID1 : Server | none > .
endm

mod COOKIE-WRAPPER is
    protecting CLIENT-SERVER .

    sorts CStoredCookiePair Cookie WrappedClientId WrappedServerId .
    subsorts WrappedClientId WrappedServerId < Oid .
    --- sorts WrappedClient WrappedServer .
    --- subsorts WrappedClient WrappedServer < Object .
    subsort Cookie < Nat .

    ops WrappedClient WrappedServer : -> Cid [ctor] .
    op wrapClientId : ClientId -> WrappedClientId .
    op wrapServerId : ServerId -> WrappedServerId .
    op (_,_) : ServerId Cookie -> CStoredCookiePair [ctor] .
    op cookieNone : -> CStoredCookiePair [ctor] .
    op msgNone : -> Msg [ctor] . *** Does this incorrectly get treated as a real message to deliver?
    op natToCookie : Nat -> Cookie [ctor] .

    op seed:_ : Nat -> Attribute [ctor gather (&)] .
    op pendingMsg:_ : Msg -> Attribute [ctor gather (&)] .
    op cookie:_ : CStoredCookiePair -> Attribute [ctor gather (&)] .
    op sendMsg:_ : Bool -> Attribute [ctor gather (&)] . *** Flag for client to send message once it has cookie.

    --- Extra message stuff.
    op (to_,connect from_) : WrappedServerId WrappedClientId -> Msg [ctor msg] .
    op (to_,accept with _ from_) : WrappedClientId Cookie WrappedServerId -> Msg [ctor msg] .
    op msgCookie:_ : Cookie -> Attribute [ctor gather (&)] .
    op clientConf:_ : Configuration -> Attribute [ctor gather (&)] .

    var CLIENTID1 : ClientId .
    var SERVERID1 : ServerId .
    var WRAPPEDCLIENTID1 : WrappedClientId .
    var WRAPPEDSERVERID1 : WrappedServerId .
    var CCONF1 : ClientConf .
    var SCONF1 : ServerConf .
    var K : Cookie .
    var MSG1 : Msg .
    vars ATTRS1 ATTRS2 : AttributeSet .
    vars N1 N2 N3 : Nat .

    rl [client-send-new-connect] : < wrapClientId(CLIENTID1) : WrappedClient | cookie: cookieNone, clientConf: (CCONF1 c; (to SERVERID1, ATTRS2 from CLIENTID1)), pendingMsg: msgNone, ATTRS1 > =>
        (to wrapServerId(SERVERID1), connect from wrapClientId(CLIENTID1)) < CLIENTID1 : WrappedClient | cookie: cookieNone, clientConf: CCONF1, 
        pendingMsg: (to SERVERID1, ATTRS2 from CLIENTID1), sendMsg: true, ATTRS1 > .

    rl [client-rcv-connect] : (to wrapClientId(CLIENTID1), accept with K from wrapServerId(SERVERID1)) < CLIENTID1 : WrappedClient | ATTRS1 > =>
        < CLIENTID1 : WrappedClient | cookie: (SERVERID1, K), ATTRS1 > .

    rl [client-send-new-data] : < wrapClientId(CLIENTID1) : WrappedClient | cookie: (SERVERID1, K), clientConf: (CCONF1 c; (to SERVERID1, ATTRS2 from CLIENTID1)), pendingMsg: msgNone, ATTRS1 > =>
        (to wrapServerId(SERVERID1), (ATTRS2, msgCookie: K) from wrapClientId(CLIENTID1)) 
        < CLIENTID1 : WrappedClient | cookie: (SERVERID1, K), clientConf: CCONF1, pendingMsg: (to SERVERID1, ATTRS2 from CLIENTID1), sendMsg: false, ATTRS1 > .

    rl [client-send-pending-data] : < wrapClientId(CLIENTID1) : WrappedClient | cookie: (SERVERID1, K), pendingMsg: (to SERVERID1, ATTRS2 from CLIENTID1), sendMsg: true, ATTRS1 > =>
        (to wrapServerId(SERVERID1), (ATTRS2, msgCookie: K) from wrapClientId(CLIENTID1)) 
        < CLIENTID1 : WrappedClient | cookie: (SERVERID1, K), pendingMsg: (to SERVERID1, ATTRS2 from CLIENTID1), sendMsg: false, ATTRS1 > .

    --- Passes any message to the internal client (does not filter old ones) but clears pendingMsg if this is a response with the awaited sequence number.
    rl [client-rcv-data] : (to wrapClientId(CLIENTID1), (msgSeq: N1, ATTRS2) from wrapServerId(SERVERID1)) < CLIENTID1 : WrappedClient | clientConf: CCONF1, pendingMsg: MSG1, ATTRS1 > => 
        < CLIENTID1 : WrappedClient | clientConf: ((to CLIENTID1, (msgSeq: N1, ATTRS2) from SERVERID1) c; CCONF1), 
        pendingMsg: (if (MSG1 == (to SERVERID1, (msgSeq: N1, ATTRS2) from CLIENTID1)) then msgNone else MSG1 fi), ATTRS1 > .

    --- This rule needs to send another cookie request and set sendMsg: True.
    --- rl [client-timeout-req] :

    --- rl [server-rcv-connect-req] :
    --- rl [server-rcv-data-req] :
    --- rl [server-rcv-finish-req] :
endm

--- set trace on .
--- set trace eq off .
--- frewrite < C 1 : Client | server: S 1, seq: 0, ack: 0, maxSeq: 3 > < S 1 : Server | none > .
--- frewrite < C 1 : Client | server: S 1, seq: 0, ack: 0, maxSeq: 1 > < C 2 : Client | server: S 1, seq: 0, ack: 0, maxSeq: 4 > < S 1 : Server | none > .

--- frewrite < wrapClientId(C 1) : WrappedClient | cookie: cookieNone, clientConf: C< C 1 : Client | server: S 1, seq: 0, ack: 0, maxSeq: 3 > > .
frewrite < wrapClientId(C 1) : WrappedClient | cookie: (S 1, natToCookie(5)), clientConf: C< C 1 : Client | server: S 1, seq: 0, ack: 0, maxSeq: 3 > > .

--- TODO:
--- Is there a better way to produce cookies?
--- Does msgNone incorrectly get treated as a real message to deliver (see comment)?